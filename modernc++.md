# 现代C++语法学习笔记

## 右值引用与完美转发
1. 左值是可以取地址的表达式，右值是不可以取地址的表达式。
2. 右值引用是配合移动构造函数和移动赋值函数使用的，其目的是为了提高效率。其本身并不会有特别大的意义，即`int&& a = 1;`这样的语句并没有什么意义。
3. 右值引用和移动语义允许我们在使用临时对象时避免不必要的拷贝。
4. 关闭编译器优化，拷贝构造函数会在传参、返回值、赋值时被调用。
5. 右值引用就是对右值的引用，但本身该变量是一个左值。
6. `std::move()`函数是移动语义，其作用是把一个左值强制转换为右值。使用了move函数意味着原对象不可再被使用，同时其资源被转移给新的对象。
7. 完美转发
   - 语法坍塌：当函数的参数为T&&，但传入的是左值，那么推导后函数的形式参数为T&。如果传入的是右值，那么推导后的函数形式参数为T&&。当函数的参数为T&时，无论传入的是左值还是右值，都将推导为T&。
   - 右值引用的变量本身是左值。
   - `std::forward() == static_cast<T&&>()`，可以实现完美转发。如果传入的是右值，那么推导后的函数形式参数为T&&，不会再出现之前的问题。如果传入的是左值，根据坍塌规则，也还是保持当前类型。
   - `auto&&`最安全
8. 移动构造函数和移动赋值函数的目的都是为了用一个右值引用的类对象去初始化另外一个类对象。
9. 移动语义只支持class type，对于诸如int、double等non-class type，移动语义不起作用。
10. 移动构造函数的触发无疑都是用一个右值去初始化一个类对象
   - `A a = A();`
   - `A a = f(A a);`
   - `A a = std::move(b)`

11. 移动赋值函数在用一个类变量给另外一个类变量赋值的时候会被调用
    - `A a; a = A();`
    - `A a; a = f(A a);`
    - `A a; a = std::move(b);`

12. 移动语义本质上是资源的移交，而不是复制。而想要调用移动构造函数，就一定要传入一个右值，才能被右值引用所捕捉。
13. 如果有移动构造函数的话，编译器不会自动生成拷贝构造函数，因此需要自己手动实现。一个良好的习惯是，拷贝和移动构造函数均实现。
14. 引用坍塌规则只适用于参数传递，也就是函数调用的时候，不适用于普通的赋值。
15. 引用传递/赋值的本质是常指针，本身不能变，但指向的内容可以变。`int &b = a; b = 1; <==> int *const b = &a; *b = 1;`
16. C++的参数传递，返回值传递本质上都是赋值操作

```C++
#include <iomanip>
#include <iostream>
#include <string>
#include <utility>
 
struct A
{
    std::string s;
    int k;
 
    A() : s("test"), k(-1) {}
    A(const A& o) : s(o.s), k(o.k) { std::cout << "move failed!\n"; }
    A(A&& o) noexcept :
        s(std::move(o.s)),       // explicit move of a member of class type
        k(std::exchange(o.k, 0)) // explicit move of a member of non-class type
        // exchange returns the old value of o.k
    {}
};

A a();
A b = std::move(a); // calls the move constructor

```